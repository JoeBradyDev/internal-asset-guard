package service

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/jackc/pgx/v5/pgtype"
	"asset-service/internal/db"
	"asset-service/internal/dto"
	"asset-service/proto"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// ListAssets implements the paginated retrieval of assets with their JSONB details
func (s *AssetServer) ListAssets(ctx context.Context, req *proto.ListAssetsRequest) (*proto.ListAssetsResponse, error) {
	rows, err := s.Queries.ListFullAssetsPaged(ctx, db.ListFullAssetsPagedParams{
		Limit:  req.Limit,
		Offset: req.Offset,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list assets: %w", err)
	}

	var assets []*proto.AssetResponse
	for _, row := range rows {
		assetRes := &proto.AssetResponse{
			Id:            row.ID,
			Name:          row.Name,
			AssetClassId:  row.AssetClassID,
			AssetClass:    row.AssetClass,
			CriticalityId: row.CriticalityID,
			Criticality:   row.Criticality,
			CreatedAt:     timestamppb.New(row.CreatedAt.Time),
		}

		// Row fields are accessed via PascalCase generated by SQLC
		if len(row.DeviceInfo) > 0 {
			var d proto.DeviceDetail
			if err := json.Unmarshal(row.DeviceInfo, &d); err == nil {
				assetRes.DeviceInfo = &d
			}
		}
		if len(row.NetworkInfo) > 0 {
			var n proto.NetworkDetail
			if err := json.Unmarshal(row.NetworkInfo, &n); err == nil {
				assetRes.NetworkInfo = &n
			}
		}
		if len(row.SoftwareInfo) > 0 {
			var sw proto.SoftwareDetail
			if err := json.Unmarshal(row.SoftwareInfo, &sw); err == nil {
				assetRes.SoftwareInfo = &sw
			}
		}
		assets = append(assets, assetRes)
	}
	return &proto.ListAssetsResponse{Assets: assets}, nil
}

func (s *AssetServer) GetAsset(ctx context.Context, req *proto.GetAssetRequest) (*proto.AssetResponse, error) {
	row, err := s.Queries.GetFullAsset(ctx, req.Id)
	if err != nil {
		return nil, err
	}
	res := &proto.AssetResponse{
		Id:            row.ID,
		Name:          row.Name,
		AssetClassId:  row.AssetClassID,
		AssetClass:    row.AssetClass,
		CriticalityId: row.CriticalityID,
		Criticality:   row.Criticality,
		CreatedAt:     timestamppb.New(row.CreatedAt.Time),
	}
	if len(row.DeviceInfo) > 0 {
		json.Unmarshal(row.DeviceInfo, &res.DeviceInfo)
	}
	if len(row.NetworkInfo) > 0 {
		json.Unmarshal(row.NetworkInfo, &res.NetworkInfo)
	}
	if len(row.SoftwareInfo) > 0 {
		json.Unmarshal(row.SoftwareInfo, &res.SoftwareInfo)
	}
	return res, nil
}

func (s *AssetServer) CreateAsset(ctx context.Context, req *proto.CreateAssetRequest) (*proto.AssetResponse, error) {
	asset, err := s.Queries.CreateAsset(ctx, db.CreateAssetParams{
		Name:          req.Name,
		AssetClassID:  req.AssetClassId,
		CriticalityID: req.CriticalityId,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create asset: %w", err)
	}

	if req.DeviceInfo != nil {
		params := db.CreateDeviceDetailParams{
			AssetID: asset.ID,
		}
		if req.DeviceInfo.Hostname != nil {
			params.Hostname = *req.DeviceInfo.Hostname
		}
		if req.DeviceInfo.DeviceTypeId != nil {
			params.DeviceTypeID = *req.DeviceInfo.DeviceTypeId
		}
		if req.DeviceInfo.IpAddress != nil {
			params.IpAddress = pgtype.Text{String: *req.DeviceInfo.IpAddress, Valid: true}
		}
		if req.DeviceInfo.MacAddress != nil {
			params.MacAddress = pgtype.Text{String: *req.DeviceInfo.MacAddress, Valid: true}
		}
		if req.DeviceInfo.OsName != nil {
			params.OsName = pgtype.Text{String: *req.DeviceInfo.OsName, Valid: true}
		}
		if req.DeviceInfo.OsVersion != nil {
			params.OsVersion = pgtype.Text{String: *req.DeviceInfo.OsVersion, Valid: true}
		}
		if req.DeviceInfo.HardwareCpe != nil {
			params.HardwareCpe = pgtype.Text{String: *req.DeviceInfo.HardwareCpe, Valid: true}
		}

		_, err := s.Queries.CreateDeviceDetail(ctx, params)
		if err != nil {
			return nil, fmt.Errorf("failed to create device detail: %w", err)
		}
	}

	if req.NetworkInfo != nil {
		params := db.CreateNetworkDetailParams{
			AssetID: asset.ID,
		}
		if req.NetworkInfo.ManagementIp != nil {
			params.ManagementIp = pgtype.Text{String: *req.NetworkInfo.ManagementIp, Valid: true}
		}
		if req.NetworkInfo.DeviceTypeId != nil {
			params.DeviceTypeID = *req.NetworkInfo.DeviceTypeId
		}
		if req.NetworkInfo.MacAddress != nil {
			params.MacAddress = pgtype.Text{String: *req.NetworkInfo.MacAddress, Valid: true}
		}
		if req.NetworkInfo.FirmwareVersion != nil {
			params.FirmwareVersion = pgtype.Text{String: *req.NetworkInfo.FirmwareVersion, Valid: true}
		}
		if req.NetworkInfo.ModelNumber != nil {
			params.ModelNumber = pgtype.Text{String: *req.NetworkInfo.ModelNumber, Valid: true}
		}
		if req.NetworkInfo.SerialNumber != nil {
			params.SerialNumber = pgtype.Text{String: *req.NetworkInfo.SerialNumber, Valid: true}
		}
		if req.NetworkInfo.TotalPorts != nil {
			params.TotalPorts = pgtype.Int4{Int32: *req.NetworkInfo.TotalPorts, Valid: true}
		}

		_, err := s.Queries.CreateNetworkDetail(ctx, params)
		if err != nil {
			return nil, fmt.Errorf("failed to create network detail: %w", err)
		}
	}

	if req.SoftwareInfo != nil {
		params := db.CreateSoftwareDetailParams{
			AssetID: asset.ID,
		}
		if req.SoftwareInfo.Name != nil {
			params.Name = *req.SoftwareInfo.Name
		}
		if req.SoftwareInfo.OsName != nil {
			params.OsName = pgtype.Text{String: *req.SoftwareInfo.OsName, Valid: true}
		}
		if req.SoftwareInfo.OsVersion != nil {
			params.OsVersion = pgtype.Text{String: *req.SoftwareInfo.OsVersion, Valid: true}
		}
		if req.SoftwareInfo.Version != nil {
			params.Version = pgtype.Text{String: *req.SoftwareInfo.Version, Valid: true}
		}
		if req.SoftwareInfo.Vendor != nil {
			params.Vendor = pgtype.Text{String: *req.SoftwareInfo.Vendor, Valid: true}
		}
		if req.SoftwareInfo.SoftwareCpe != nil {
			params.SoftwareCpe = pgtype.Text{String: *req.SoftwareInfo.SoftwareCpe, Valid: true}
		}

		_, err := s.Queries.CreateSoftwareDetail(ctx, params)
		if err != nil {
			return nil, fmt.Errorf("failed to create software detail: %w", err)
		}
	}

	return s.GetAsset(ctx, &proto.GetAssetRequest{Id: asset.ID})
}

func (s *AssetServer) UpdateAsset(ctx context.Context, req *proto.UpdateAssetRequest) (*proto.AssetResponse, error) {
	current, err := s.Queries.GetAssetByID(ctx, req.Id)
	if err != nil {
		return nil, err
	}

	acid := int(current.AssetClassID)
	critid := int(current.CriticalityID)
	dtoUpdate := dto.UpdateAsset{
		Name:          &current.Name,
		AssetClassID:  &acid,
		CriticalityID: &critid,
	}

	if req.Name != nil { dtoUpdate.Name = req.Name }
	if req.AssetClassId != nil {
		v := int(*req.AssetClassId)
		dtoUpdate.AssetClassID = &v
	}
	if req.CriticalityId != nil {
		v := int(*req.CriticalityId)
		dtoUpdate.CriticalityID = &v
	}

	updated, err := s.Queries.UpdateAsset(ctx, db.UpdateAssetParams{
		ID:            current.ID,
		Name:          *dtoUpdate.Name,
		AssetClassID:  int32(*dtoUpdate.AssetClassID),
		CriticalityID: int32(*dtoUpdate.CriticalityID),
	})
	if err != nil {
		return nil, err
	}

	return &proto.AssetResponse{
		Id:            updated.ID,
		Name:          updated.Name,
		AssetClassId:  updated.AssetClassID,
		CriticalityId: updated.CriticalityID,
		CreatedAt:     timestamppb.New(updated.CreatedAt.Time),
	}, nil
}

func (s *AssetServer) DeleteAsset(ctx context.Context, req *proto.DeleteAssetRequest) (*proto.Empty, error) {
	err := s.Queries.DeleteAsset(ctx, req.Id)
	return &proto.Empty{}, err
}
