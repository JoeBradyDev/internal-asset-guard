// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notes.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAssetNote = `-- name: CreateAssetNote :one
INSERT INTO asset_note (
    asset_id,
    asset_issue_id,
    author_user_id,
    content
) VALUES (
    $1, -- asset_id
    $2, -- asset_issue_id (can be null)
    $3, -- author_user_id
    $4  -- content
)
RETURNING id, asset_id, asset_issue_id, author_user_id, content, created_at
`

type CreateAssetNoteParams struct {
	AssetID      int32
	AssetIssueID pgtype.Int4
	AuthorUserID int32
	Content      string
}

func (q *Queries) CreateAssetNote(ctx context.Context, arg CreateAssetNoteParams) (AssetNote, error) {
	row := q.db.QueryRow(ctx, createAssetNote,
		arg.AssetID,
		arg.AssetIssueID,
		arg.AuthorUserID,
		arg.Content,
	)
	var i AssetNote
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.AssetIssueID,
		&i.AuthorUserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAssetNote = `-- name: DeleteAssetNote :exec
DELETE FROM asset_note WHERE id = $1
`

func (q *Queries) DeleteAssetNote(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAssetNote, id)
	return err
}

const getNoteByID = `-- name: GetNoteByID :one
SELECT id, asset_id, asset_issue_id, author_user_id, content, created_at FROM asset_note WHERE id = $1
`

func (q *Queries) GetNoteByID(ctx context.Context, id int32) (AssetNote, error) {
	row := q.db.QueryRow(ctx, getNoteByID, id)
	var i AssetNote
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.AssetIssueID,
		&i.AuthorUserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}

const getNotesByAssetID = `-- name: GetNotesByAssetID :many
SELECT id, asset_id, asset_issue_id, author_user_id, content, created_at FROM asset_note
WHERE asset_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetNotesByAssetID(ctx context.Context, assetID int32) ([]AssetNote, error) {
	rows, err := q.db.Query(ctx, getNotesByAssetID, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssetNote
	for rows.Next() {
		var i AssetNote
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.AssetIssueID,
			&i.AuthorUserID,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssetNote = `-- name: UpdateAssetNote :one
UPDATE asset_note
SET
    asset_issue_id = $2,
    content = $3
WHERE id = $1
RETURNING id, asset_id, asset_issue_id, author_user_id, content, created_at
`

type UpdateAssetNoteParams struct {
	ID           int32
	AssetIssueID pgtype.Int4
	Content      string
}

func (q *Queries) UpdateAssetNote(ctx context.Context, arg UpdateAssetNoteParams) (AssetNote, error) {
	row := q.db.QueryRow(ctx, updateAssetNote, arg.ID, arg.AssetIssueID, arg.Content)
	var i AssetNote
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.AssetIssueID,
		&i.AuthorUserID,
		&i.Content,
		&i.CreatedAt,
	)
	return i, err
}
