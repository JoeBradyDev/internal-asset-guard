// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: issues.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAssetIssue = `-- name: CreateAssetIssue :one
INSERT INTO asset_issue (
    asset_id,
    issue_type_id,
    status_id,
    issue_source_id,
    external_issue_id,
    description
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, asset_id, issue_type_id, status_id, issue_source_id, external_issue_id, description, created_at, updated_at
`

type CreateAssetIssueParams struct {
	AssetID         int32
	IssueTypeID     int32
	StatusID        int32
	IssueSourceID   int32
	ExternalIssueID string
	Description     pgtype.Text
}

func (q *Queries) CreateAssetIssue(ctx context.Context, arg CreateAssetIssueParams) (AssetIssue, error) {
	row := q.db.QueryRow(ctx, createAssetIssue,
		arg.AssetID,
		arg.IssueTypeID,
		arg.StatusID,
		arg.IssueSourceID,
		arg.ExternalIssueID,
		arg.Description,
	)
	var i AssetIssue
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.IssueTypeID,
		&i.StatusID,
		&i.IssueSourceID,
		&i.ExternalIssueID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAssetIssue = `-- name: DeleteAssetIssue :exec
DELETE FROM asset_issue
WHERE id = $1
`

func (q *Queries) DeleteAssetIssue(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAssetIssue, id)
	return err
}

const getIssueByID = `-- name: GetIssueByID :one
SELECT
    i.id, i.asset_id, i.issue_type_id, i.status_id, i.issue_source_id, i.external_issue_id, i.description, i.created_at, i.updated_at, cat.name as category_name, it.name as type_name, stat.name as status_name, isrc.name as source_name
FROM asset_issue i
JOIN issue_type it ON i.issue_type_id = it.id
JOIN cis_issue_category cat ON it.category_id = cat.id
JOIN cis_issue_status stat ON i.status_id = stat.id
JOIN issue_source isrc ON i.issue_source_id = isrc.id
WHERE i.id = $1
`

type GetIssueByIDRow struct {
	ID              int32
	AssetID         int32
	IssueTypeID     int32
	StatusID        int32
	IssueSourceID   int32
	ExternalIssueID string
	Description     pgtype.Text
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	CategoryName    string
	TypeName        string
	StatusName      string
	SourceName      string
}

func (q *Queries) GetIssueByID(ctx context.Context, id int32) (GetIssueByIDRow, error) {
	row := q.db.QueryRow(ctx, getIssueByID, id)
	var i GetIssueByIDRow
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.IssueTypeID,
		&i.StatusID,
		&i.IssueSourceID,
		&i.ExternalIssueID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategoryName,
		&i.TypeName,
		&i.StatusName,
		&i.SourceName,
	)
	return i, err
}

const getIssuesByAssetID = `-- name: GetIssuesByAssetID :many
SELECT
    i.id, i.asset_id, i.issue_type_id, i.status_id, i.issue_source_id, i.external_issue_id, i.description, i.created_at, i.updated_at, cat.name as category_name, it.name as type_name, stat.name as status_name, isrc.name as source_name
FROM asset_issue i
JOIN issue_type it ON i.issue_type_id = it.id
JOIN cis_issue_category cat ON it.category_id = cat.id
JOIN cis_issue_status stat ON i.status_id = stat.id
JOIN issue_source isrc ON i.issue_source_id = isrc.id
WHERE i.asset_id = $1
`

type GetIssuesByAssetIDRow struct {
	ID              int32
	AssetID         int32
	IssueTypeID     int32
	StatusID        int32
	IssueSourceID   int32
	ExternalIssueID string
	Description     pgtype.Text
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	CategoryName    string
	TypeName        string
	StatusName      string
	SourceName      string
}

func (q *Queries) GetIssuesByAssetID(ctx context.Context, assetID int32) ([]GetIssuesByAssetIDRow, error) {
	rows, err := q.db.Query(ctx, getIssuesByAssetID, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIssuesByAssetIDRow
	for rows.Next() {
		var i GetIssuesByAssetIDRow
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.IssueTypeID,
			&i.StatusID,
			&i.IssueSourceID,
			&i.ExternalIssueID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
			&i.TypeName,
			&i.StatusName,
			&i.SourceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssetIssue = `-- name: UpdateAssetIssue :one
UPDATE asset_issue
SET
    issue_type_id = $2,
    status_id = $3,
    issue_source_id = $4,
    external_issue_id = $5,
    description = $6,
    updated_at = NOW()
WHERE id = $1
RETURNING id, asset_id, issue_type_id, status_id, issue_source_id, external_issue_id, description, created_at, updated_at
`

type UpdateAssetIssueParams struct {
	ID              int32
	IssueTypeID     int32
	StatusID        int32
	IssueSourceID   int32
	ExternalIssueID string
	Description     pgtype.Text
}

func (q *Queries) UpdateAssetIssue(ctx context.Context, arg UpdateAssetIssueParams) (AssetIssue, error) {
	row := q.db.QueryRow(ctx, updateAssetIssue,
		arg.ID,
		arg.IssueTypeID,
		arg.StatusID,
		arg.IssueSourceID,
		arg.ExternalIssueID,
		arg.Description,
	)
	var i AssetIssue
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.IssueTypeID,
		&i.StatusID,
		&i.IssueSourceID,
		&i.ExternalIssueID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
