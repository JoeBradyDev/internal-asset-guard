// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assets.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAssetSourceMap = `-- name: AddAssetSourceMap :exec

INSERT INTO asset_source_map (asset_id, asset_source_id)
VALUES ($1, $2)
`

type AddAssetSourceMapParams struct {
	AssetID       int32
	AssetSourceID int32
}

// - 2. ASSET SOURCE MAPPING ---
func (q *Queries) AddAssetSourceMap(ctx context.Context, arg AddAssetSourceMapParams) error {
	_, err := q.db.Exec(ctx, addAssetSourceMap, arg.AssetID, arg.AssetSourceID)
	return err
}

const createAsset = `-- name: CreateAsset :one

INSERT INTO asset (name, asset_class_id, criticality_id)
VALUES ($1, $2, $3)
RETURNING id, name, asset_class_id, criticality_id, created_at
`

type CreateAssetParams struct {
	Name          string
	AssetClassID  int32
	CriticalityID int32
}

// - 1. ASSET CORE ---
func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) (Asset, error) {
	row := q.db.QueryRow(ctx, createAsset, arg.Name, arg.AssetClassID, arg.CriticalityID)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AssetClassID,
		&i.CriticalityID,
		&i.CreatedAt,
	)
	return i, err
}

const createDeviceDetail = `-- name: CreateDeviceDetail :one

INSERT INTO device_detail (
    asset_id, hostname, device_type_id, ip_address, mac_address, os_name, os_version, hardware_cpe, last_seen
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING asset_id, hostname, device_type_id, ip_address, mac_address, os_name, os_version, hardware_cpe, last_seen
`

type CreateDeviceDetailParams struct {
	AssetID      int32
	Hostname     string
	DeviceTypeID int32
	IpAddress    pgtype.Text
	MacAddress   pgtype.Text
	OsName       pgtype.Text
	OsVersion    pgtype.Text
	HardwareCpe  pgtype.Text
	LastSeen     pgtype.Timestamptz
}

// - 3. DETAILS (DEVICE, NETWORK, SOFTWARE) ---
func (q *Queries) CreateDeviceDetail(ctx context.Context, arg CreateDeviceDetailParams) (DeviceDetail, error) {
	row := q.db.QueryRow(ctx, createDeviceDetail,
		arg.AssetID,
		arg.Hostname,
		arg.DeviceTypeID,
		arg.IpAddress,
		arg.MacAddress,
		arg.OsName,
		arg.OsVersion,
		arg.HardwareCpe,
		arg.LastSeen,
	)
	var i DeviceDetail
	err := row.Scan(
		&i.AssetID,
		&i.Hostname,
		&i.DeviceTypeID,
		&i.IpAddress,
		&i.MacAddress,
		&i.OsName,
		&i.OsVersion,
		&i.HardwareCpe,
		&i.LastSeen,
	)
	return i, err
}

const createNetworkDetail = `-- name: CreateNetworkDetail :one
INSERT INTO network_detail (
    asset_id, management_ip, device_type_id, mac_address, firmware_version, model_number, serial_number, total_ports, last_seen
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING asset_id, management_ip, device_type_id, mac_address, firmware_version, model_number, serial_number, total_ports, last_seen
`

type CreateNetworkDetailParams struct {
	AssetID         int32
	ManagementIp    pgtype.Text
	DeviceTypeID    int32
	MacAddress      pgtype.Text
	FirmwareVersion pgtype.Text
	ModelNumber     pgtype.Text
	SerialNumber    pgtype.Text
	TotalPorts      pgtype.Int4
	LastSeen        pgtype.Timestamptz
}

func (q *Queries) CreateNetworkDetail(ctx context.Context, arg CreateNetworkDetailParams) (NetworkDetail, error) {
	row := q.db.QueryRow(ctx, createNetworkDetail,
		arg.AssetID,
		arg.ManagementIp,
		arg.DeviceTypeID,
		arg.MacAddress,
		arg.FirmwareVersion,
		arg.ModelNumber,
		arg.SerialNumber,
		arg.TotalPorts,
		arg.LastSeen,
	)
	var i NetworkDetail
	err := row.Scan(
		&i.AssetID,
		&i.ManagementIp,
		&i.DeviceTypeID,
		&i.MacAddress,
		&i.FirmwareVersion,
		&i.ModelNumber,
		&i.SerialNumber,
		&i.TotalPorts,
		&i.LastSeen,
	)
	return i, err
}

const createSoftwareDetail = `-- name: CreateSoftwareDetail :one
INSERT INTO software_detail (asset_id, name, os_name, os_version, version, vendor, software_cpe, last_seen)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING asset_id, name, os_name, os_version, version, vendor, software_cpe, last_seen
`

type CreateSoftwareDetailParams struct {
	AssetID     int32
	Name        string
	OsName      pgtype.Text
	OsVersion   pgtype.Text
	Version     pgtype.Text
	Vendor      pgtype.Text
	SoftwareCpe pgtype.Text
	LastSeen    pgtype.Timestamptz
}

func (q *Queries) CreateSoftwareDetail(ctx context.Context, arg CreateSoftwareDetailParams) (SoftwareDetail, error) {
	row := q.db.QueryRow(ctx, createSoftwareDetail,
		arg.AssetID,
		arg.Name,
		arg.OsName,
		arg.OsVersion,
		arg.Version,
		arg.Vendor,
		arg.SoftwareCpe,
		arg.LastSeen,
	)
	var i SoftwareDetail
	err := row.Scan(
		&i.AssetID,
		&i.Name,
		&i.OsName,
		&i.OsVersion,
		&i.Version,
		&i.Vendor,
		&i.SoftwareCpe,
		&i.LastSeen,
	)
	return i, err
}

const deleteAsset = `-- name: DeleteAsset :exec
DELETE FROM asset WHERE id = $1
`

func (q *Queries) DeleteAsset(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAsset, id)
	return err
}

const deleteDeviceDetail = `-- name: DeleteDeviceDetail :exec
DELETE FROM device_detail WHERE asset_id = $1
`

func (q *Queries) DeleteDeviceDetail(ctx context.Context, assetID int32) error {
	_, err := q.db.Exec(ctx, deleteDeviceDetail, assetID)
	return err
}

const deleteNetworkDetail = `-- name: DeleteNetworkDetail :exec
DELETE FROM network_detail WHERE asset_id = $1
`

func (q *Queries) DeleteNetworkDetail(ctx context.Context, assetID int32) error {
	_, err := q.db.Exec(ctx, deleteNetworkDetail, assetID)
	return err
}

const deleteSoftwareDetail = `-- name: DeleteSoftwareDetail :exec
DELETE FROM software_detail WHERE asset_id = $1
`

func (q *Queries) DeleteSoftwareDetail(ctx context.Context, assetID int32) error {
	_, err := q.db.Exec(ctx, deleteSoftwareDetail, assetID)
	return err
}

const getAssetByID = `-- name: GetAssetByID :one
SELECT id, name, asset_class_id, criticality_id, created_at FROM asset WHERE id = $1
`

func (q *Queries) GetAssetByID(ctx context.Context, id int32) (Asset, error) {
	row := q.db.QueryRow(ctx, getAssetByID, id)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AssetClassID,
		&i.CriticalityID,
		&i.CreatedAt,
	)
	return i, err
}

const getDeviceDetail = `-- name: GetDeviceDetail :one
SELECT asset_id, hostname, device_type_id, ip_address, mac_address, os_name, os_version, hardware_cpe, last_seen FROM device_detail
WHERE asset_id = $1
`

func (q *Queries) GetDeviceDetail(ctx context.Context, assetID int32) (DeviceDetail, error) {
	row := q.db.QueryRow(ctx, getDeviceDetail, assetID)
	var i DeviceDetail
	err := row.Scan(
		&i.AssetID,
		&i.Hostname,
		&i.DeviceTypeID,
		&i.IpAddress,
		&i.MacAddress,
		&i.OsName,
		&i.OsVersion,
		&i.HardwareCpe,
		&i.LastSeen,
	)
	return i, err
}

const getFullAsset = `-- name: GetFullAsset :one

SELECT
    a.id, a.name, a.created_at,
    a.asset_class_id,
    cl.name AS asset_class,
    cr.id AS criticality_id,
    cr.name AS criticality,
    (SELECT row_to_json(dt) FROM (
        SELECT d.asset_id, d.hostname, d.device_type_id, d.ip_address, d.mac_address, d.os_name, d.os_version, d.hardware_cpe, d.last_seen, l.name as device_type
        FROM device_detail d
        JOIN device_type l ON d.device_type_id = l.id
        WHERE d.asset_id = a.id
    ) dt) AS device_info,
    (SELECT row_to_json(nt) FROM (
        SELECT n.asset_id, n.management_ip, n.device_type_id, n.mac_address, n.firmware_version, n.model_number, n.serial_number, n.total_ports, n.last_seen, l.name as device_type
        FROM network_detail n
        JOIN device_type l ON n.device_type_id = l.id
        WHERE n.asset_id = a.id
    ) nt) AS network_info,
    (SELECT row_to_json(s) FROM software_detail s WHERE s.asset_id = a.id) AS software_info
FROM asset a
JOIN cis_asset_class cl ON a.asset_class_id = cl.id
JOIN cis_asset_criticality cr ON a.criticality_id = cr.id
WHERE a.id = $1
`

type GetFullAssetRow struct {
	ID            int32
	Name          string
	CreatedAt     pgtype.Timestamptz
	AssetClassID  int32
	AssetClass    string
	CriticalityID int32
	Criticality   string
	DeviceInfo    []byte
	NetworkInfo   []byte
	SoftwareInfo  []byte
}

// - 4. COMPLEX RETRIEVAL ---
func (q *Queries) GetFullAsset(ctx context.Context, id int32) (GetFullAssetRow, error) {
	row := q.db.QueryRow(ctx, getFullAsset, id)
	var i GetFullAssetRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.AssetClassID,
		&i.AssetClass,
		&i.CriticalityID,
		&i.Criticality,
		&i.DeviceInfo,
		&i.NetworkInfo,
		&i.SoftwareInfo,
	)
	return i, err
}

const getNetworkDetail = `-- name: GetNetworkDetail :one
SELECT asset_id, management_ip, device_type_id, mac_address, firmware_version, model_number, serial_number, total_ports, last_seen FROM network_detail
WHERE asset_id = $1
`

func (q *Queries) GetNetworkDetail(ctx context.Context, assetID int32) (NetworkDetail, error) {
	row := q.db.QueryRow(ctx, getNetworkDetail, assetID)
	var i NetworkDetail
	err := row.Scan(
		&i.AssetID,
		&i.ManagementIp,
		&i.DeviceTypeID,
		&i.MacAddress,
		&i.FirmwareVersion,
		&i.ModelNumber,
		&i.SerialNumber,
		&i.TotalPorts,
		&i.LastSeen,
	)
	return i, err
}

const getSoftwareDetail = `-- name: GetSoftwareDetail :one
SELECT asset_id, name, os_name, os_version, version, vendor, software_cpe, last_seen FROM software_detail
WHERE asset_id = $1
`

func (q *Queries) GetSoftwareDetail(ctx context.Context, assetID int32) (SoftwareDetail, error) {
	row := q.db.QueryRow(ctx, getSoftwareDetail, assetID)
	var i SoftwareDetail
	err := row.Scan(
		&i.AssetID,
		&i.Name,
		&i.OsName,
		&i.OsVersion,
		&i.Version,
		&i.Vendor,
		&i.SoftwareCpe,
		&i.LastSeen,
	)
	return i, err
}

const getSourcesByAsset = `-- name: GetSourcesByAsset :many
SELECT s.id, s.name FROM asset_source s
JOIN asset_source_map asm ON s.id = asm.asset_source_id
WHERE asm.asset_id = $1
`

func (q *Queries) GetSourcesByAsset(ctx context.Context, assetID int32) ([]AssetSource, error) {
	rows, err := q.db.Query(ctx, getSourcesByAsset, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssetSource
	for rows.Next() {
		var i AssetSource
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFullAssetsPaged = `-- name: ListFullAssetsPaged :many
SELECT
    a.id, a.name, a.created_at,
    a.asset_class_id,
    cl.name AS asset_class,
    cr.id AS criticality_id,
    cr.name AS criticality,
    (SELECT row_to_json(dt) FROM (
        SELECT d.asset_id, d.hostname, d.device_type_id, d.ip_address, d.mac_address, d.os_name, d.os_version, d.hardware_cpe, d.last_seen, l.name as device_type
        FROM device_detail d
        JOIN device_type l ON d.device_type_id = l.id
        WHERE d.asset_id = a.id
    ) dt) AS device_info,
    (SELECT row_to_json(nt) FROM (
        SELECT n.asset_id, n.management_ip, n.device_type_id, n.mac_address, n.firmware_version, n.model_number, n.serial_number, n.total_ports, n.last_seen, l.name as device_type
        FROM network_detail n
        JOIN device_type l ON n.device_type_id = l.id
        WHERE n.asset_id = a.id
    ) nt) AS network_info,
    (SELECT row_to_json(s) FROM software_detail s WHERE s.asset_id = a.id) AS software_info,
    (SELECT count(*) FROM asset_issue WHERE asset_id = a.id) as total_issues
FROM asset a
JOIN cis_asset_class cl ON a.asset_class_id = cl.id
JOIN cis_asset_criticality cr ON a.criticality_id = cr.id
WHERE ($3::int = 0 OR a.asset_class_id = $3)
  AND ($4::int = 0 OR a.criticality_id = $4)
ORDER BY a.id ASC
LIMIT $1 OFFSET $2
`

type ListFullAssetsPagedParams struct {
	Limit   int32
	Offset  int32
	Column3 int32
	Column4 int32
}

type ListFullAssetsPagedRow struct {
	ID            int32
	Name          string
	CreatedAt     pgtype.Timestamptz
	AssetClassID  int32
	AssetClass    string
	CriticalityID int32
	Criticality   string
	DeviceInfo    []byte
	NetworkInfo   []byte
	SoftwareInfo  []byte
	TotalIssues   int64
}

func (q *Queries) ListFullAssetsPaged(ctx context.Context, arg ListFullAssetsPagedParams) ([]ListFullAssetsPagedRow, error) {
	rows, err := q.db.Query(ctx, listFullAssetsPaged,
		arg.Limit,
		arg.Offset,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFullAssetsPagedRow
	for rows.Next() {
		var i ListFullAssetsPagedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.AssetClassID,
			&i.AssetClass,
			&i.CriticalityID,
			&i.Criticality,
			&i.DeviceInfo,
			&i.NetworkInfo,
			&i.SoftwareInfo,
			&i.TotalIssues,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAssetFromSource = `-- name: RemoveAssetFromSource :exec
DELETE FROM asset_source_map
WHERE asset_id = $1 AND asset_source_id = $2
`

type RemoveAssetFromSourceParams struct {
	AssetID       int32
	AssetSourceID int32
}

func (q *Queries) RemoveAssetFromSource(ctx context.Context, arg RemoveAssetFromSourceParams) error {
	_, err := q.db.Exec(ctx, removeAssetFromSource, arg.AssetID, arg.AssetSourceID)
	return err
}

const updateAsset = `-- name: UpdateAsset :one
UPDATE asset
SET name = $2, asset_class_id = $3, criticality_id = $4
WHERE id = $1
RETURNING id, name, asset_class_id, criticality_id, created_at
`

type UpdateAssetParams struct {
	ID            int32
	Name          string
	AssetClassID  int32
	CriticalityID int32
}

func (q *Queries) UpdateAsset(ctx context.Context, arg UpdateAssetParams) (Asset, error) {
	row := q.db.QueryRow(ctx, updateAsset,
		arg.ID,
		arg.Name,
		arg.AssetClassID,
		arg.CriticalityID,
	)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AssetClassID,
		&i.CriticalityID,
		&i.CreatedAt,
	)
	return i, err
}

const updateDeviceDetail = `-- name: UpdateDeviceDetail :one
UPDATE device_detail
SET
    hostname = $2,
    device_type_id = $3,
    ip_address = $4,
    mac_address = $5,
    os_name = $6,
    os_version = $7,
    hardware_cpe = $8,
    last_seen = $9
WHERE asset_id = $1
RETURNING asset_id, hostname, device_type_id, ip_address, mac_address, os_name, os_version, hardware_cpe, last_seen
`

type UpdateDeviceDetailParams struct {
	AssetID      int32
	Hostname     string
	DeviceTypeID int32
	IpAddress    pgtype.Text
	MacAddress   pgtype.Text
	OsName       pgtype.Text
	OsVersion    pgtype.Text
	HardwareCpe  pgtype.Text
	LastSeen     pgtype.Timestamptz
}

func (q *Queries) UpdateDeviceDetail(ctx context.Context, arg UpdateDeviceDetailParams) (DeviceDetail, error) {
	row := q.db.QueryRow(ctx, updateDeviceDetail,
		arg.AssetID,
		arg.Hostname,
		arg.DeviceTypeID,
		arg.IpAddress,
		arg.MacAddress,
		arg.OsName,
		arg.OsVersion,
		arg.HardwareCpe,
		arg.LastSeen,
	)
	var i DeviceDetail
	err := row.Scan(
		&i.AssetID,
		&i.Hostname,
		&i.DeviceTypeID,
		&i.IpAddress,
		&i.MacAddress,
		&i.OsName,
		&i.OsVersion,
		&i.HardwareCpe,
		&i.LastSeen,
	)
	return i, err
}

const updateNetworkDetail = `-- name: UpdateNetworkDetail :one
UPDATE network_detail
SET
    management_ip = $2,
    device_type_id = $3,
    mac_address = $4,
    firmware_version = $5,
    model_number = $6,
    serial_number = $7,
    total_ports = $8,
    last_seen = $9
WHERE asset_id = $1
RETURNING asset_id, management_ip, device_type_id, mac_address, firmware_version, model_number, serial_number, total_ports, last_seen
`

type UpdateNetworkDetailParams struct {
	AssetID         int32
	ManagementIp    pgtype.Text
	DeviceTypeID    int32
	MacAddress      pgtype.Text
	FirmwareVersion pgtype.Text
	ModelNumber     pgtype.Text
	SerialNumber    pgtype.Text
	TotalPorts      pgtype.Int4
	LastSeen        pgtype.Timestamptz
}

func (q *Queries) UpdateNetworkDetail(ctx context.Context, arg UpdateNetworkDetailParams) (NetworkDetail, error) {
	row := q.db.QueryRow(ctx, updateNetworkDetail,
		arg.AssetID,
		arg.ManagementIp,
		arg.DeviceTypeID,
		arg.MacAddress,
		arg.FirmwareVersion,
		arg.ModelNumber,
		arg.SerialNumber,
		arg.TotalPorts,
		arg.LastSeen,
	)
	var i NetworkDetail
	err := row.Scan(
		&i.AssetID,
		&i.ManagementIp,
		&i.DeviceTypeID,
		&i.MacAddress,
		&i.FirmwareVersion,
		&i.ModelNumber,
		&i.SerialNumber,
		&i.TotalPorts,
		&i.LastSeen,
	)
	return i, err
}

const updateSoftwareDetail = `-- name: UpdateSoftwareDetail :one
UPDATE software_detail
SET
    name = $2,
    os_name = $3,
    os_version = $4,
    version = $5,
    vendor = $6,
    software_cpe = $7,
    last_seen = $8
WHERE asset_id = $1
RETURNING asset_id, name, os_name, os_version, version, vendor, software_cpe, last_seen
`

type UpdateSoftwareDetailParams struct {
	AssetID     int32
	Name        string
	OsName      pgtype.Text
	OsVersion   pgtype.Text
	Version     pgtype.Text
	Vendor      pgtype.Text
	SoftwareCpe pgtype.Text
	LastSeen    pgtype.Timestamptz
}

func (q *Queries) UpdateSoftwareDetail(ctx context.Context, arg UpdateSoftwareDetailParams) (SoftwareDetail, error) {
	row := q.db.QueryRow(ctx, updateSoftwareDetail,
		arg.AssetID,
		arg.Name,
		arg.OsName,
		arg.OsVersion,
		arg.Version,
		arg.Vendor,
		arg.SoftwareCpe,
		arg.LastSeen,
	)
	var i SoftwareDetail
	err := row.Scan(
		&i.AssetID,
		&i.Name,
		&i.OsName,
		&i.OsVersion,
		&i.Version,
		&i.Vendor,
		&i.SoftwareCpe,
		&i.LastSeen,
	)
	return i, err
}
